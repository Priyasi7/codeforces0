# -*- coding: utf-8 -*-
"""Tree Quiz.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FmJjMANIsqclTmTHPTG__5vjKBA9Jvon
"""

import sys
sys.setrecursionlimit(300000)

MOD = 998244353  # not needed here, but standard practice

def build_lca(n, parents):
    LOG = 17  # since 2^17 > 1e5
    up = [[0] * (LOG + 1) for _ in range(n + 1)]
    depth = [0] * (n + 1)
    root = 1
    for i in range(1, n + 1):
        if parents[i] == 0:
            root = i

    # build tree
    g = [[] for _ in range(n + 1)]
    for i in range(1, n + 1):
        if parents[i] != 0:
            g[parents[i]].append(i)

    def dfs(u, p):
        up[u][0] = p
        for j in range(1, LOG + 1):
            up[u][j] = up[up[u][j-1]][j-1]
        for v in g[u]:
            depth[v] = depth[u] + 1
            dfs(v, u)

    dfs(root, 0)
    return up, depth

def lca(u, v, up, depth):
    LOG = len(up[0]) - 1
    if depth[u] < depth[v]:
        u, v = v, u
    # lift u up
    diff = depth[u] - depth[v]
    for j in range(LOG, -1, -1):
        if diff & (1 << j):
            u = up[u][j]
    if u == v:
        return u
    for j in range(LOG, -1, -1):
        if up[u][j] != up[v][j]:
            u = up[u][j]
            v = up[v][j]
    return up[u][0]

def main():
    input = sys.stdin.readline
    n, q = map(int, input().split())
    parents = [0] + list(map(int, input().split()))

    up, depth = build_lca(n, parents)

    for _ in range(q):
        k = int(input())
        x = (k - 1) // n + 1
        y = (k - 1) % n + 1
        l = lca(x, y, up, depth)
        ans = (x - 1) * n * n + (l - 1) * n + (y - 1)
        print(ans)

if __name__ == "__main__":
    main()