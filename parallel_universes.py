# -*- coding: utf-8 -*-
"""Parallel Universes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qBViAfENgDcfDNAsMmCgHg6iejhs2Eve
"""

class DSU:
    def __init__(self, n):
        self.parent = list(range(n + 1))
        self.rank = [0] * (n + 1)

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        x_root = self.find(x)
        y_root = self.find(y)
        if x_root == y_root:
            return False
        if self.rank[x_root] < self.rank[y_root]:
            self.parent[x_root] = y_root
        else:
            self.parent[y_root] = x_root
            if self.rank[x_root] == self.rank[y_root]:
                self.rank[x_root] += 1
        return True

import sys
input = sys.stdin.readline

t, g = map(int, input().split())
for _ in range(t):
    n, m1, m2 = map(int, input().split())

    edges_B = []
    edges_C = []

    for _ in range(m1):
        u, v = map(int, input().split())
        edges_B.append((u, v))
    for _ in range(m2):
        u, v = map(int, input().split())
        edges_C.append((u, v))

    dsu_B = DSU(n)
    dsu_C = DSU(n)

    for u, v in edges_B:
        dsu_B.union(u, v)
    for u, v in edges_C:
        dsu_C.union(u, v)

    spells = []

    # Try all pairs (i,j) to connect different components in B without breaking C
    for i in range(1, n + 1):
        for j in range(i + 1, n + 1):
            if dsu_B.find(i) != dsu_B.find(j) and dsu_C.find(i) == dsu_C.find(j):
                dsu_B.union(i, j)
                spells.append((i, j))

    # Check if B fully connected
    root = dsu_B.find(1)
    connected = all(dsu_B.find(i) == root for i in range(1, n + 1))

    if connected:
        print("Yes")
        print(len(spells))
        for u, v in spells:
            print(u, v)
    else:
        print("No")