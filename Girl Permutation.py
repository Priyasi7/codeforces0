# -*- coding: utf-8 -*-
"""Untitled32.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qBViAfENgDcfDNAsMmCgHg6iejhs2Eve
"""

import sys
input = sys.stdin.readline

MOD = 10**9 + 7

def solve():
    t = int(input())
    for _ in range(t):
        n, m1, m2 = map(int, input().split())
        p = list(map(int, input().split()))
        s = list(map(int, input().split()))

        # If last prefix max index != last suffix max index -> impossible
        if p[-1] != s[-1]:
            print(0)
            continue

        # mark prefix/suffix maxima indices
        is_pref = [False] * (n + 1)
        is_suff = [False] * (n + 1)
        for x in p:
            is_pref[x] = True
        for x in s:
            is_suff[x] = True

        # two-pointer to track current maximums
        pref_ptr, suff_ptr = 0, 0
        ans = 1

        for i in range(1, n + 1):
            choices = 0
            if is_pref[i] and is_suff[i]:
                # forced index of the maximum element
                continue
            elif is_pref[i]:
                # forced as prefix maximum
                continue
            elif is_suff[i]:
                # forced as suffix maximum
                continue
            else:
                # free index: can take any element not fixed elsewhere
                # choices = min(#remaining prefix max not yet used, #remaining suffix max not yet used)
                left_needed = len(p) - pref_ptr
                right_needed = len(s) - suff_ptr
                choices = min(left_needed, right_needed)
                ans = (ans * choices) % MOD

            if pref_ptr < len(p) and p[pref_ptr] == i:
                pref_ptr += 1
            if suff_ptr < len(s) and s[suff_ptr] == i:
                suff_ptr += 1

        print(ans % MOD)


if __name__ == "__main__":
    solve()