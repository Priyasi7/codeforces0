# -*- coding: utf-8 -*-
"""Burenka and Pether.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qBViAfENgDcfDNAsMmCgHg6iejhs2Eve
"""

import sys
from collections import deque
input = sys.stdin.readline

def solve():
    n, d, g = map(int, input().split())
    a = list(map(int, input().split()))
    q = int(input())

    max_reach = [0] * n
    dq = deque()

    # Precompute max_reach using sliding window
    for i in range(n):
        while dq and dq[0] <= i:
            dq.popleft()
        for j in range(i+1, min(n, i+d+1)):
            if a[j] > a[i]:
                max_reach[i] = j
                break

    # Binary lifting table
    LOG = 20  # enough for 2^20 > 3*10^5
    jump = [[-1]*LOG for _ in range(n)]
    for i in range(n):
        jump[i][0] = max_reach[i]

    for k in range(1, LOG):
        for i in range(n):
            if jump[i][k-1] != -1:
                jump[i][k] = jump[jump[i][k-1]][k-1]

    # Answer queries
    for _ in range(q):
        t, u, v = map(int, input().split())
        u -= 1; v -= 1
        if a[u] >= a[v]:
            print(0)
            continue

        if t == 1:
            # Reachability
            pos = u
            for k in reversed(range(LOG)):
                if jump[pos][k] != -1 and jump[pos][k] < v:
                    pos = jump[pos][k]
            if pos != -1 and max_reach[pos] >= v:
                print(1)
            else:
                print(0)
        else:
            # Minimum transfers
            pos = u
            ans = 0
            for k in reversed(range(LOG)):
                if jump[pos][k] != -1 and jump[pos][k] < v:
                    pos = jump[pos][k]
                    ans += (1<<k)
            if pos != -1 and max_reach[pos] >= v:
                ans += 1
                print(ans)
            else:
                print(0)

if __name__ == "__main__":
    solve()