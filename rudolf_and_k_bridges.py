# -*- coding: utf-8 -*-
"""Rudolf and k Bridges.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qBViAfENgDcfDNAsMmCgHg6iejhs2Eve
"""

import sys
from collections import deque

input = sys.stdin.readline

def min_bridge_cost(row, m, d):
    dp = [0] * m
    # cost of first support at j=0
    dp[0] = row[0] + 1  # but row[0] is always 0, so dp[0] = 1

    dq = deque([0])  # store indices with increasing dp

    for j in range(1, m):
        # remove indices too far (gap > d)
        while dq and dq[0] < j - d:
            dq.popleft()

        # dp[j] = cost of this support + best dp within range
        dp[j] = row[j] + 1 + dp[dq[0]]

        # maintain monotonic deque
        while dq and dp[dq[-1]] >= dp[j]:
            dq.pop()
        dq.append(j)

    return dp[m-1]  # cost to reach last column

def solve():
    t = int(input())
    for _ in range(t):
        n, m, k, d = map(int, input().split())
        grid = [list(map(int, input().split())) for _ in range(n)]

        # Step 1: compute per-row minimum bridge cost
        row_costs = []
        for i in range(n):
            cost = min_bridge_cost(grid[i], m, d)
            row_costs.append(cost)

        # Step 2: find minimal sum of k consecutive rows
        window_sum = sum(row_costs[:k])
        best = window_sum
        for i in range(k, n):
            window_sum += row_costs[i] - row_costs[i-k]
            best = min(best, window_sum)

        print(best)

if __name__ == "__main__":
    solve()